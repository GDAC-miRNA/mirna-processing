#!/usr/bin/perl

# originally from Andy Chu at BCGSC

# generates "mature" microRNA expression values based on premature miRNA data
# in DCC Level 3 data

use strict;
use Getopt::Std;
use vars qw ($opt_m $opt_o $opt_p $opt_h $opt_n);
getopts('m:o:p:h:n:');
use File::Find;
use File::Basename;

my $help_text = "
############## $0 ########################

Generates mature microRNA expression values from Level 3 DCC miRNA isoform files as generated by mirna_profiling_pipeline/tcga.pl (isoforms.txt) 

Requires miRBase in ADF format for looking up miR names from MIMAT IDs. 
   Use create_adf_mirbase_w_5p_3p_annotations.pl to generate ADF files for miRBase versions that do not use star-stand annotations
   ADF file must be sorted by miRNA_ID
   Expected ADF format is:
   miRNA_ID miRBase_Ver Accession Genomic_Coords Precursor_Seq Mature_Coords Mature_Accession Alt_Mature_Coords Alt_Mature_Accession [obsolete: Star_Coords Star_Accession]

   Note that for later versions of miRBase the Star_Coords and Star_Accession have been discontinued. Comment out the optional code section below when Star_Coords are not required.

3 versions of the expression matrix are created.
expn_matrix_mimat_<modifier>.txt: matrix with raw read counts
expn_matrix_mimat_norm_<modifier>.txt: matrix with normalized counts (counts per million mature miRNA aligned tags)
expn_matrix_mimat_norm_log_<modifier>.txt: as above, but values are taken to log2 (log(0) is written out as 0)

Usage: $0 -m miRNA_ADF -o Output_directory -p Level_3_archive_directory -n <modifier>

########################################################
";

if ($opt_h || !($opt_o && $opt_m && $opt_p && $opt_n)) { print $help_text; exit 1; }

my $norm_factor = 1000000; #Normalize to this number of tags
my $log0 = "0"; #log(0) can be written out as other strings, eg. "NA"

#Data structure
my %genes; #hash gene->sample->value
my @genes; #full list of gene names
my %samples; #hash of samples->total tags
my %sample_names; #sample names
my %mimats; #maps MIMAT id to a unique miRNA id

########################################################
# Find files in Level_3_archive_directory
print STDERR "Searching for input files in project directory...\n";
my @mirnafiles;
find(\&findinputfiles, $opt_p);
print STDERR "Input files found\n";
die "No input files found in $opt_p" unless scalar @mirnafiles;
@mirnafiles = sort @mirnafiles;

########################################################
# Read in gene list using ADF file to map MIMAT IDs to miR names and generate
# a unique identifier for each MIMAT
# MIMAT identifiers are generated as follows: a "common" miRNA (the common component shared between miRNA names) followed by the MIMAT ID
# e.g.
# hsa-mir-181a and hsa-mir-181b gets trimmed down to hsa-mir-181
# hsa-mir-941-1 and hsa-mir-941-2 gets trimmed down to hsa-mir-941
# genes is a list of all of the unique identifiers generated for the MIMAT IDs in the ADF

my ($genes, $mimats) = get_mirna_genes($opt_m);

# genes is a list of all of the unique identifiers generated for the MIMAT IDs in the ADF
@genes = @$genes;

# mimats is a lookup table that maps the MIMAT IDs to their common miR names
%mimats = %$mimats;

########################################################
# Read in miRNA expression from level 3 expression files
foreach my $source (@mirnafiles) {
	 # comment out when using locally generated isoforms.txt files
    my $sample = basename($source, ".isoform.quantification.txt");
    
	 # uncomment when using locally generated isoforms.txt files
    # my $sample = basename(dirname(dirname($source)));
    # $sample =~ s/_features//g;
    print("$sample\n")
    $sample_names{$sample} = 1;

    my $sample_total = 0; # Total tag count for sample based on isoforms file
    open(FH, $source) || die "Cannot open expression file $source: $!";
    while(<FH>) {
        chomp;
        my ($mirna, $coords, $count, $norm_count, $crossmap, $annot) = split;
        # Ignore anything that's not a mature or star strand
        # count cross-mapped reads towards each annotation they map to
        my ($mature, $acc) = split(',', $annot);
        next unless $mature eq 'mature' || $mature eq 'star';
        # Use the MIMAT ID from the isoforms file ($acc) as a key to retrieve the common miR name for that MIMAT from the common miR name lookup table and generate a compound MIMAT identifer: <common miR name>.<MIMAT ID>
        my $id = $mimats{$acc}.".".$acc;
        # Add the number of reads for this isoform to the total for this unique identifier for this sample 
        $genes{$id}{$sample} += $count;
        $sample_total += $count;
    }
    close(FH);
    $samples{$sample} = $sample_total;
}

#Expression matrix header
my $header = "Gene";
foreach my $sample (sort keys %sample_names) {
    $header .= "\t$sample";
}
$header .= "\n";

#Write expression matrix
open RAW, ">$opt_o/expn_matrix_mimat_$opt_n.txt" or die "Can't write out expression matrix $opt_p/expn_matrix_mimat_$opt_n.txt: $!\n";
open NORM, ">$opt_o/expn_matrix_mimat_norm_$opt_n.txt" or die "Can't write out expression matrix $opt_p/expn_matrix_mimat_norm_$opt_n.txt: $!\n";
open LOG, ">$opt_o/expn_matrix_mimat_norm_log_$opt_n.txt" or die "Can't write out expression matrix $opt_p/expn_matrix_mimat_norm_log_$opt_n.txt: $!\n";
print RAW $header;
print NORM $header;
print LOG $header;

foreach my $gene (@genes) {
    print RAW "$gene";
    print NORM "$gene";
    print LOG "$gene";

    foreach my $sample (sort keys %sample_names) {
        my $count = $genes{$gene}{$sample} || 0;
        my $norm_count;
        my $log_count;
        if ($samples{$sample} == 0) {
            $norm_count = 0;
            $log_count = $log0;
        }
        else {
            $norm_count = sprintf("%.6f", $count*$norm_factor/$samples{$sample});
            $log_count = sprintf("%.6f", $norm_count == $log0 ? 0 : log($norm_count) / log(2));
        }

        print RAW "\t$count";
        print NORM "\t$norm_count";
        print LOG "\t$log_count";
    }
    print RAW "\n";
    print NORM "\n";
    print LOG "\n";
}

close RAW;
close NORM;
close LOG;

sub get_mirna_genes {
	# generates two arrays:
	# mirnas: a list of all of the unique identifiers generated for the MIMAT IDs found in an isoforms file
	# mimats: a lookup table that maps MIMAT IDs to their common miR names
    my $adf = shift;

    my (%mirnas, %mimats);

    open FH, "<$adf" or die "Cannot read ADF reference $adf: $!\n";
    while (<FH>) {
        my @fields = split;
        chomp @fields;
        # ADF field order (Note: ADF must be sorted by miRNA_ID):
        # 1 miRNA_ID 
        # 2 miRBase_Ver 
        # 3 Accession 
        # 4 Genomic_Coords 
        # 5 Precursor_Seq 
        # 6 Mature_Coords 
        # 7 Mature_Accession 
        # 8 Alt_Mature_Coords 
        # 9 Alt_Mature_Accession 
        #10 Star_Coords (obsolete)
        #11 Star_Accession (obsolete)
        
        # Read in miRNA_ID
        my $mirna_id = $fields[0];
        next if $mirna_id eq "miRNA_ID"; #skip header
        # Read in Mature_Coords
        my @mimats = ($fields[6]);
        # Read in Alt_Mature_Coords unless empty
        push(@mimats, $fields[8]) unless $fields[8] eq "";
        # Read in Star_Coords unless empty
        ##############################################################
        # OPTIONAL CODE
        # Comment out the following line when using miRBase versions 
        # that do not utilize STAR strand annotation are required. 
        # push(@mimats, $fields[10]) unless $fields[10] eq "";
        ##############################################################
        foreach my $mimat (@mimats) {
            unless (exists $mimats{$mimat}) {
            # If this MIMAT has been seen before,
            # track the miRNA_id associated with the MIMAT
                $mimats{$mimat} = $mirna_id; 
                $mirnas{"$mirna_id.$mimat"} = 1;
                next;
            }
            # If this MIMAT has not been seen yet, 
            # find the common miRNA_id to use for the MIMAT and 
            # add the <common mirna name>.<mimat> to the hash
            my $trimmed_mirna_id = trim_id($mirna_id, $mimats{$mimat}); 
            delete($mirnas{"$mimats{$mimat}.$mimat"});
            $mirnas{"$trimmed_mirna_id.$mimat"} = 1;
            $mimats{$mimat} = $trimmed_mirna_id;
        }
    }
    close FH;
    my @mirnas = sort keys %mirnas;
    return \@mirnas, \%mimats;
}

sub trim_id {
    #if this MIMAT has been seen before, it belongs to multiple similar miRNAs
    #use a "common" miRNA name which is the common component shared between miRNA names
    #eg.
    #hsa-mir-181a and hsa-mir-181b gets trimmed down to hsa-mir-181
    #hsa-mir-941-1 and hsa-mir-941-2 gets trimmed down to hsa-mir-941
    #hsa-mir-941 and hsa-mir-941-3 gets trimmed down to hsa-mir-941 (this happens when the miRNA_id has been processed once already)
    my $id1 = shift;
    my $id2 = shift;

    my $minlen = length($id1);
    $minlen = length($id2) if length($id2) < $minlen;

    #walk backwards through the strings until they're equal
    for (my $i = $minlen; $i >=0; $i--) {
        my $sub_id1 = substr($id1, 0, $i);
        my $sub_id2 = substr($id2, 0, $i);
        if ($sub_id1 eq $sub_id2) {
            #remove trailing - if necessary
            $sub_id1 =~ s/-$//;
            return $sub_id1;
        }
    }
    die "No common substring between $id1 and $id2 for the same MIMAT."
}

# Uncomment to use locally generated isoforms.txt files rather than DCC level 3
# archive <TCGAID>.isoform.quantification.txt files
# sub findinputfiles {
#    if ($File::Find::name =~ /tcga\/isoforms.txt$/) {
#        push(@mirnafiles, $File::Find::name);
#        print STDERR "\t$File::Find::name\n";
#    }
}

# Comment out when using locally generated isoforms.txt files
 sub findinputfiles {
    if ($File::Find::name =~ /.isoform.quantification.txt$/) {
        push(@mirnafiles, $File::Find::name);
        print STDERR "\t$File::Find::name\n";
    }
}


